_e82‍.x([["setPos",()=>setPos],["setFacing",()=>setFacing],["turnFacing",()=>turnFacing],["moveRobot",()=>moveRobot]]);// Import packages to perform I/O:

const fs = require("fs");
const readline = require("readline");

let inputArray = [];

function processLineByLine() {
  const fileStream = fs.createReadStream("index.txt");

  const rl = readline.createInterface({
    input: fileStream,
    crlfDelay: Infinity
  });
  // Note: we use the crlfDelay option to recognize all instances of CR LF
  // ('\r\n') in input.txt as a single line break.

  let stdin_input = "";
  let currentPos = null;

  rl.on("line", line => {
    // Each line in input.txt will be successively available here as `line`.
    const instruction = line.toUpperCase();
    // Process Instruction
    currentPos = processInstruction(currentPos, instruction);
  });
}

processLineByLine();

function processInstruction(currentPos, instructionCmd) {
  var newPos = currentPos;
  var instructionCmdArr = instructionCmd.toString().split(" ");
  var instruction = instructionCmdArr[0];
  switch (instruction) {
    case "PLACE":
      var idealPos = processNewPos(instructionCmdArr[1]);
      if (idealPos) {
        newPos = idealPos;
      }
      break;

    case "MOVE":
      if (newPos) {
        newPos = moveRobot(currentPos);
      }
      break;

    case "LEFT":
    case "RIGHT":
      // Turning Right, anti-CW 90degree
      if (newPos) {
        newPos = turnFacing(currentPos, instruction);
      }
      break;

    case "REPORT":
      if (newPos) {
        console.log(newPos.x + "," + newPos.y + "," + newPos.facing + "\n");
      }
      break;
  }
  return newPos;
}

function processNewPos(instructionCmdArr) {
  const parsePos = instructionCmdArr.toString().split(",");
  return setPos(parsePos[0], parsePos[1], parsePos[2]);
}

function setPos(x, y, f) {
  if (x >= 0 && x <= 5 && y >= 0 && y <= 5) {
    return {
      x: parseInt(x),
      y: parseInt(y),
      facing: f
    };
  } else {
    return null;
  }
}

function setFacing(currentPos, f) {
  if (f) {
    switch (f) {
      case "NORTH":
      case "SOUTH":
      case "EAST":
      case "WEST":
        currentPos.facing = f;
        break;
    }
  }
  return currentPos;
}

function turnFacing(currentPos, newDirection) {
  const currentDirection = currentPos.facing;
  let newFacing = "";
  switch (currentDirection) {
    case "NORTH":
      switch (newDirection) {
        case "LEFT":
          newFacing = "WEST";
          break;

        case "RIGHT":
          newFacing = "EAST";
          break;
      }
      break;

    case "SOUTH":
      switch (newDirection) {
        case "LEFT":
          newFacing = "EAST";
          break;

        case "RIGHT":
          newFacing = "WEST";
          break;
      }
      break;
    case "EAST":
      switch (newDirection) {
        case "LEFT":
          newFacing = "NORTH";
          break;

        case "RIGHT":
          newFacing = "SOUTH";
          break;
      }
      break;
    case "WEST":
      switch (newDirection) {
        case "LEFT":
          newFacing = "SOUTH";
          break;

        case "RIGHT":
          newFacing = "NORTH";
          break;
      }
      break;
  }
  return setFacing(currentPos, newFacing);
}

function moveRobot(currentPos) {
  const currentDirection = currentPos.facing;
  var posX = currentPos.x;
  var posY = currentPos.y;

  switch (currentDirection) {
    case "NORTH":
      if (posY + 1 <= 5) {
        posY = posY + 1;
      }
      break;
    case "SOUTH":
      if (posY - 1 >= 0) {
        posY = posY - 1;
      }
      break;
    case "EAST":
      if (posX + 1 <= 5) {
        posX = posX + 1;
      }
      break;
    case "WEST":
      if (posX - 1 >= 0) {
        posX = posX - 1;
      }
      break;
  }
  return {
    x: posX,
    y: posY,
    facing: currentDirection
  };
}


/*
UNIT TESTING
* each function
** processInstruction
** processNewPos

** setPos
*** check if setPos
--> 0,0,NORTH
--> 5,5,SOUTH
--> 2,3,SOUTH

** setFacing
*** check if at position North
--> south, south
--> east, east
*** check if at position East
--> north, north
--> west, west

** turnFacing
*** check if at position North
--> left, West
--> right, East
*** check if at position South
--> left, West
--> right, East
*** check if at position East
--> left, North
--> right, South
*** check if at position West
--> left, South
--> right, North

** moveRobot
*** check if at 2,2, below asserts to true
--> north 2,3
--> south 2,1
--> east 3,2
--> west 1,2
*** check if at 0,0, below asserts to true
--> south 0,0
--> west 0,0
*** check if at 5,5, below asserts to true
--> north 5,5
--> east 5,5


TEST DATA

PLACE 0,0,NORTH
MOVE
REPORT
Output: 0,1,NORTH

PLACE 0,0,NORTH
LEFT
REPORT
Output: 0,0,WEST

PLACE 1,2,EAST
MOVE
MOVE
LEFT
MOVE
REPORT
Output: 3,3,NORTH



Integration Test

MOVE
MOVE
PLACE 4,5,WEST
MOVE
LEFT
MOVE
MOVE
MOVE
MOVE
MOVE
MOVE
LEFT
MOVE
MOVE
MOVE
MOVE
MOVE
MOVE
LEFT
MOVE
MOVE
MOVE
MOVE
MOVE
MOVE
MOVE
LEFT
MOVE
MOVE
MOVE
MOVE
MOVE
MOVE
LEFT
MOVE
MOVE
LEFT
MOVE
MOVE
RIGHT
REPORT

Output: 2,3,SOUTH

PLACE 0,0,NORTH
MOVE
MOVE
MOVE
LEFT
MOVE
MOVE
RIGHT
RIGHT
MOVE
MOVE
PLACE 6,5,SOUTH
MOVE
MOVE
MOVE

*/
